
***

### **Lab: Generate and Use a Digital Signature**

#### **Objective:**
To use the `openssl` command-line tool to create a public/private key pair, digitally sign a document, and verify the signature's authenticity and integrity.

#### **Core Concepts:**
A digital signature provides two key security services:
1.  **Authenticity:** Proof that the document was signed by the holder of the corresponding private key.
2.  **Integrity:** Proof that the document has not been altered or tampered with since it was signed.

*   The **Private Key** is kept secret and is used to **create** the signature.
*   The **Public Key** is shared openly and is used to **verify** the signature.

---

### **Part 1: Key Generation**

1.  **Generate a Private Key:**
    *   Creates an RSA private key and saves it to a file.
    ```bash
    openssl genpkey -algorithm RSA -out private_key.pem
    ```

2.  **Extract the Public Key from the Private Key:**
    *   Reads the private key and extracts the corresponding public key.
    ```bash
    openssl pkey -in private_key.pem -pubout -out public_key.pem
    ```

---

### **Part 2: Signing and Verification**

1.  **Create a Document to Sign:**
    ```bash
    echo "Please transfer 2,000,000 US Dollars to Mr. Jester by 6pm today!" > contract.txt
    ```

2.  **Create the Digital Signature:**
    *   This command calculates a SHA-256 hash of `contract.txt` and then uses the **private key** to encrypt that hash, creating the signature file.
    ```bash
    openssl dgst -sha256 -sign private_key.pem -out signature contract.txt
    ```

3.  **Verify the Signature (Successful):**
    *   This command uses the **public key** to decrypt the signature, revealing the original hash. It then calculates a new hash of `contract.txt`. If the hashes match, the signature is valid.
    ```bash
    openssl dgst -sha256 -verify public_key.pem -signature signature contract.txt
    ```
    *   **Expected Output:** `Verified OK`

---

### **Part 3: Demonstrating the Integrity Check**

1.  **Simulate Tampering:**
    *   The `contract.txt` file is edited (e.g., changing "Mr. Jester" to "Mr. Viper").

2.  **Attempt to Verify the Altered Document:**
    *   The exact same verification command is run again on the modified document.
    ```bash
    openssl dgst -sha256 -verify public_key.pem -signature signature contract.txt
    ```
    *   **Expected Output:** `Verification Failure`

---

### **Conclusion / Key Takeaway**

The verification failed because the content of `contract.txt` was changed. This caused its new SHA-256 hash to be different from the original hash stored in the signature. This process proves that a digital signature effectively guarantees a document's **integrity**; any modification, no matter how small, will invalidate the signature.