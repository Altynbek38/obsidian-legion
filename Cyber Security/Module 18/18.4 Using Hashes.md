
---
# 18.4.1: Hashing Files and Digital Media

#### Core Concept
Hashing is a fundamental tool for ensuring the **integrity** of digital filesâ€”proving that they are complete and have not been altered.

---
#### Use Case 1: Verifying Software Downloads
*   **Scenario:** A network administrator downloads a critical software file, like a Cisco IOS image, from a website.
*   **The Risk:** The file could have been corrupted during the download, or a malicious actor could have replaced the legitimate file with a compromised version.
*   **The Solution:**
    1.  The software vendor (Cisco) publishes the official **MD5 or SHA hash** of the file on their secure website.
    2.  After downloading the file, the administrator uses a hashing tool to calculate the hash of the file they just received.
    3.  The administrator **compares** their calculated hash with the official hash published by the vendor.
    *   **Result:** If the hashes match, the administrator can be confident that the downloaded file is authentic and has not been tampered with.

---
#### Use Case 2: Digital Forensics
*   **Scenario:** A forensic examiner needs to analyze the contents of a hard drive for evidence.
*   **The Risk:** Directly working on the original drive could accidentally (or intentionally) alter the evidence, making it invalid in court.
*   **The Solution (Establishing "Fixity"):**
    1.  The examiner creates a **hash** of the entire original storage media.
    2.  The examiner makes a perfect **bit-for-bit copy** (a "digital clone") of the media.
    3.  The examiner then creates a **hash of the copy**.
    4.  The hash of the original is **compared** to the hash of the copy.
    *   **Result:** If the hashes match, it proves that the copy is an identical and uncorrupted duplicate of the original. This is called **fixity**. The examiner can now perform all analysis on the copy, leaving the original evidence pristine and legally admissible.


---

# 18.4.3: Hashing Passwords

#### The Challenge
A system needs a way to verify a user's password during login, but storing the password in plaintext is a massive security risk. If the database is ever stolen, all user passwords would be exposed.

#### The Solution: Hashing
The solution is to **never store the plaintext password**. Instead, the system stores a **one-way hash** of the password.

---
#### The Process (Registration vs. Login)

1.  **Account Registration (Setting the Password):**
    *   A new user provides their desired password.
    *   The system immediately computes the **hash** of that password.
    *   The system stores **only the hash** in its user database. The plaintext password is then discarded.

2.  **User Login (Verifying the Password):**
    *   The user enters their password at the login screen.
    *   The system computes the **hash** of the password the user just typed.
    *   The system **compares this new hash** to the hash it has stored in the database for that user.
    *   **Result:**
        *   If the hashes **match**, the password is correct and access is granted.
        *   If the hashes **do not match**, access is denied.

---
#### The Security Benefit
*   The actual password is **never written to the disk** or stored by the system.
*   If an attacker steals the password database, they only get a list of hashes, not the actual passwords.
*   Because hashing is a **one-way function**, the attacker cannot easily reverse the hashes to discover the original passwords.


---

# 18.4.4: Cracking Hashes

#### Core Concept
Because hashing is a one-way function, an attacker cannot "reverse" a stolen hash. Instead, they must **guess the original password**, hash their guess, and see if their hash matches the stolen one.

---
#### Top Two Password Guessing Attacks

| Attack Method | How it Works | Speed & Effectiveness |
| :--- | :--- | :--- |
| **Dictionary Attack** | The attacker uses a pre-compiled list (a "dictionary") of common words, phrases, and known leaked passwords. They pre-calculate the hash for every word in the list and then simply compare their list of hashes against the stolen hashes. | **Very Fast and Efficient.** This is the first method attackers use because it quickly finds all weak, common, or previously compromised passwords. |
| **Brute-Force Attack** | The attacker systematically tries every possible combination of characters (e.g., "a", "b", "c"... "aa", "ab"... "aaa", "aab"...). | **Very Slow and CPU-Intensive.** Its success depends on the password's length and complexity. It is guaranteed to eventually find the password, but the goal of a strong password is to make the time required to brute-force it impractically long. |

#### Defense
*   **Against Dictionary Attacks:** Enforce policies that require users to create **complex passwords** that are not common words or phrases.
*   **Against Brute-Force Attacks:** Enforce policies that require a **long minimum password length**. Each additional character exponentially increases the time needed to crack it.



---

# 18.4.7: Salting

#### The Problem with Simple Hashing
If two users choose the same password (e.g., "Password123"), their stored hashes will be identical. An attacker who compromises the database can immediately identify all users who share a weak password and can use pre-computed hash lists (like rainbow tables) to crack them all at once.

---
#### The Solution: Salting
*   **What is a Salt?** A unique, random string of characters that is generated for each user.
*   **How it Works:** The salt is added to the user's plaintext password **before** it is hashed.
    `Hash(Password + Salt) = Final Stored Hash`
*   **How it's Stored:** The system stores both the unique **salt** and the final **hash** for each user in the database. The salt itself is not a secret.

---
#### The Security Benefit
Salting ensures that even if two users have the exact same password, their stored hashes will be completely **different** because their salts are different.

*   **Defeats Rainbow Tables:** Pre-computed hash lists are now useless because every hash is unique.
*   **Forces Individual Cracking:** An attacker must attempt to crack each user's password hash one by one, dramatically increasing the time and effort required to compromise accounts.


---

# 18.4.8: Implementing Salting

#### Best Practices for Salting
To implement salting securely, follow these key recommendations:

*   **Generate Strong Salts:** Use a **CSPRNG** (Cryptographically Secure Pseudo-Random Number Generator) to create salts that are long, random, and unpredictable.
*   **Unique Salts:** Every user password must have its own unique salt. Never reuse salts.
*   **Proper Salt Length:** The length of the salt should ideally match the output length of the hash function (e.g., 32 bytes for SHA-256).
*   **Server-Side Hashing:** Always perform the hashing process on the server, not on the client, to prevent manipulation.

---
#### Key Stretching (Making Hashing Slow)
*   **Concept:** A security technique that intentionally makes the hashing process slow.
*   **How it works:** It runs the hashing algorithm repeatedly, thousands of times (iterations), on the password and salt.
*   **Why it's important:** It dramatically slows down brute-force and dictionary attacks, rendering high-speed cracking hardware much less effective.

---
#### The Salting Process in Action

##### 1. Storing a New Password
1.  Generate a long, random **salt** using a CSPRNG.
2.  Combine the user's plaintext **password** with the **salt**.
3.  Hash the combined string using a strong algorithm (e.g., SHA-256).
4.  Store *both* the unique **salt** and the final **hash** in the user's database record.

##### 2. Verifying a Password at Login
1.  Retrieve the user's stored **salt** and **hash** from the database.
2.  Combine the plaintext **password** submitted by the user with the retrieved **salt**.
3.  Hash this new combination using the *exact same* hash function.
4.  Compare the newly generated hash with the stored hash. If they match, the login is successful.


---

# 18.4.9: How Salting Prevents Pre-Computation Attacks

#### Core Benefit of Salting
Salting's primary security benefit is that it defeats attacks that rely on **pre-computed hashes**. Since each user's hash is unique (`Hash(password + salt)`), pre-calculated lists of common password hashes become useless.

---
#### Common Pre-Computation Attacks Defeated by Salting

| Attack Method | How it Works (Without Salt) | How Salting Defeats It |
| :--- | :--- | :--- |
| **Lookup Table** | An attacker creates a massive database mapping common plaintext passwords directly to their corresponding hashes. Cracking is a simple, fast table lookup. | The pre-computed hash of a password (e.g., `Hash("password123")`) will **never** match the database hash, which is unique (`Hash("password123" + random_salt)`). |
| **Hash-to-Users Mapping Attack**| After a database breach, an attacker groups all users who have the **same password hash**. They only need to crack that one hash to compromise all those accounts simultaneously. | Since every user has a unique salt, users with the same password will have **different** stored hashes. The attacker cannot group them and is forced to crack each hash individually. |
| **Rainbow Table** | A space-optimized version of a lookup table. It uses complex "hash chains" to store the solutions to millions of potential hashes in a much smaller file size. | Just like with a standard lookup table, the pre-computed values are useless. The unique salt ensures the stored hash will not be found in the rainbow table. |