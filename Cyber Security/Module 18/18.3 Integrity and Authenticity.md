
---

# 18.3.1: The Four Elements of Secure Communications

**Core Concept:** To properly secure data in transit, an organization must implement controls that provide four essential security services. The overall trend is to encrypt all communications by default.

---
| Security Element | What it Guarantees | How it's Achieved (Technologies) |
| :--- | :--- | :--- |
| **Data Integrity** | Guarantees that the message has **not been altered** in transit. | **Hashing algorithms** like **SHA-2** or **SHA-3**. <br>*(MD5 is insecure and should be avoided).* |
| **Origin Authentication** | Guarantees that the message is from the stated sender and is **not a forgery**. | **HMAC** (Hash-based Message Authentication Code). |
| **Data Confidentiality** | Guarantees that only authorized parties can read the message, protecting it from eavesdropping. | **Encryption algorithms** (both Symmetric and Asymmetric). |
| **Data Non-Repudiation** | Guarantees that the sender **cannot deny** having sent the message. | **Digital Signatures** (which use asymmetric cryptography). |



# 18.3.2: Cryptographic Hash Functions

#### Core Concept
*   **Hashing** is a **one-way mathematical function** that takes an input of any size (the "message") and produces a unique, fixed-length output (the "hash").
*   **Analogy (One-Way Function):** Grinding coffee beans. It's easy to turn beans into powder, but impossible to reassemble the powder back into the original beans.

---
#### Key Terminology

| Term            | Also Known As                               | Description                                                   |
| :-------------- | :------------------------------------------ | :------------------------------------------------------------ |
| **Input Data**  | Message                                     | The variable-length data that is fed into the function.       |
| **Hash Output** | Message Digest, Digest, Digital Fingerprint | The fixed-length, condensed representation of the input data. |

---
#### Why Hashing is Secure & Useful
*   **Collision Resistance:** It is computationally impossible for two different inputs to produce the same hash output.
*   **"Avalanche Effect":** Any tiny change in the input data results in a completely different hash value.
*   **Primary Uses:** Hashing is used to verify:
    *   **Data Integrity:** To ensure data has not been accidentally corrupted or maliciously altered.
    *   **Authentication:** To confirm the identity of a user or system (e.g., password storage).


---

# 18.3.3: Cryptographic Hash Operation

#### The Mathematical Model
The operation of a hash function is described by the formula:
**`h = H(x)`**

*   **`x`**: The input **message** (of any arbitrary length).
*   **`H`**: The **hash function** or algorithm (e.g., SHA-256).
*   **`h`**: The resulting fixed-length **hash value**.

---
#### Essential Properties of a Secure Hash Function `H(x)`

1.  **Any Input Length:** It can accept an input (`x`) of any size.
2.  **Fixed Output Length:** It always produces an output (`h`) of the same, fixed length.
3.  **Easy to Compute:** Calculating `h` from a given `x` is a fast and simple process.
4.  **One-Way (Not Reversible):** It is computationally impossible to find the original input `x` if you only know the output hash `h`.
5.  **Collision Free:** Two different inputs (`x1` and `x2`) will not produce the same hash value (`h`).


Of course. This section explains the practical process of using hashing for integrity and highlights its major security limitation. Here are the concise notes.

---

# 18.3.4: Hashing for Integrity (MD5 & SHA)

#### How Hashing Verifies Integrity
This process is used to detect **accidental changes** to data during transit.

1.  **Sender:** Calculates a hash of the original message and attaches this hash to the message.
2.  **Transmission:** The message and its hash are sent together (in plaintext).
3.  **Receiver:**
    *   Separates the received message from the received hash.
    *   Calculates a **new hash** on the message it received.
    *   Compares its newly calculated hash to the hash that was sent.
    *   **Result:**
        *   If the hashes **match**, the message integrity is intact.
        *   If the hashes **do not match**, the message was altered or corrupted.

---
#### Major Hashing Algorithms

| Algorithm | Digest Size | Status & Note |
| :--- | :--- | :--- |
| **MD5** | 128-bit | **Insecure / Legacy.** Known vulnerabilities. Avoid using. |
| **SHA-1** | 160-bit | **Insecure / Legacy.** Known flaws. Avoid using. |
| **SHA-2** | 224, 256, 384, 512-bit | **Secure / Recommended.** The current industry standard. |
| **SHA-3** | 224, 256, 384, 512-bit | **Secure / Recommended.** The next-generation standard, designed as an alternative to SHA-2. |

---
#### The CRITICAL Limitation of Simple Hashing
*   **Problem:** Simple hashing only protects against **accidental** changes. It provides **no protection against a deliberate, malicious attacker**.
*   **The Attack (Man-in-the-Middle):**
    1.  An attacker intercepts the message and its original hash.
    2.  The attacker **alters the message**.
    3.  The attacker **recalculates a new hash** on the altered message.
    4.  The attacker sends the altered message with the new, valid hash to the receiver.
*   **Result:** The receiver's integrity check will **pass**, because the new hash matches the altered message. The receiver has no way of knowing the message was tampered with.

**Conclusion:** Hashing by itself provides **integrity** but **no origin authentication**. It is vulnerable to man-in-the-middle attacks.


---

# 18.3.5: Origin Authentication with HMAC

#### Core Concept
*   **HMAC (Keyed-Hash Message Authentication Code):** An improved hashing method that combines a standard hash function with a **pre-shared secret key**.
*   **Purpose:** To solve the major weakness of simple hashing. HMAC provides both **data integrity** AND **origin authentication**.

---
#### How HMAC Works
The key difference is the addition of the secret key to the calculation.

1.  **Creating the HMAC Value (Sender):**
    *   The sender combines the **plaintext message** AND the **secret key**.
    *   This combination is fed into a hash function (like SHA-256).
    *   The resulting hash is the HMAC value, which is then attached to the message.

2.  **Verifying the HMAC Value (Receiver):**
    *   The receiver separates the message from the received HMAC.
    *   The receiver combines the **plaintext message** it received with its **own copy of the secret key**.
    *   It feeds this combination into the same hash function to calculate its own HMAC.
    *   It compares its calculated HMAC with the HMAC it received.

---
#### The Security Result
*   If the HMAC values match, it proves:
    1.  **Integrity:** The message was not altered.
    2.  **Authentication:** The message must have come from a party who possesses the secret key.
*   **Man-in-the-Middle Defeated:** An attacker cannot alter the message and create a valid new HMAC because they **do not know the secret key**.

---
#### Practical Example: OSPF Authentication
*   Routers running routing protocols like OSPF can be configured with a shared secret key.
*   When a router (R1) sends a routing update (LSU) to a neighbor (R2), it calculates an HMAC using the update message and the secret key.
*   R2 receives the update and performs the same HMAC calculation. If the hashes match, R2 trusts the update as authentic and unaltered. If they don't match, the update is discarded.


