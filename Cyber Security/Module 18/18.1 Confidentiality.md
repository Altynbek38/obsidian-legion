
---

# 18.1.1: Data Confidentiality

**Core Concept:** Data confidentiality is achieved by encrypting data so only authorized parties can read it. There are two main classes of encryption algorithms, which differ in how they manage keys.

---
#### Symmetric vs. Asymmetric Encryption

| Feature           | Symmetric Encryption                                              | Asymmetric Encryption                                                 |
| :---------------- | :---------------------------------------------------------------- | :-------------------------------------------------------------------- |
| **Keys**          | Uses a **single, shared key** for both encryption and decryption. | Uses a **key pair** (a public key and a private key).                 |
| **Speed**         | **Fast** and efficient.                                           | **Slow** and computationally intensive.                               |
| **Key Length**    | Shorter keys (e.g., 128-256 bits).                                | Longer keys (e.g., 2048-4096 bits).                                   |
| **Best Use Case** | Encrypting **bulk data**.                                         | **Securely exchanging keys** and for digital signatures.              |
| **Example**       | Encrypting the actual data stream in a **VPN tunnel**.            | The initial **HTTPS handshake** to securely exchange a symmetric key. |
| **Algorithms**    | **AES** (recommended), 3DES (avoid), DES (legacy).                | **RSA**, Public Key Infrastructure (PKI).                             |


---

# 18.1.2: Symmetric Encryption

#### Core Concept
*   **Symmetric Encryption** uses a **single, pre-shared key** (also called a secret key) for both encrypting and decrypting data.
*   Both the sender and receiver must have the *exact same key* before any secure communication can happen.
*   **Key Strength:** Longer keys are more secure. A minimum key length of **128 bits** is recommended.

---
#### Common Symmetric Algorithms

| Algorithm | Status & Note |
| :--- | :--- |
| **AES** (Advanced Encryption Standard)| **Recommended.** The modern industry standard. Uses 128-, 192-, or 256-bit keys to encrypt 128-bit blocks of data. |
| **3DES** (Triple DES)| **Avoid if Possible.** A temporary replacement for DES that is slow and now being retired. |
| **DES** (Data Encryption Standard)| **Insecure / Legacy.** Its short key length makes it easy to break. **Do not use.** |
| **RC4** (Rivest Cipher 4)| **Insecure.** A stream cipher with known vulnerabilities. **Do not use.** |
| **SEAL**| A fast, software-optimized stream cipher that is an alternative to AES, designed to have a low CPU impact. |

---
#### Types of Ciphers

| Cipher Type | How it Works | Speed | Examples |
| :--- | :--- | :--- | :--- |
| **Block Cipher** | Encrypts data in fixed-size chunks or "blocks" (e.g., 64 or 128 bits at a time). | Slower, as it must fill a block before encrypting. | **AES**, DES |
| **Stream Cipher**| Encrypts data continuously, one bit or one byte at a time. | Typically **faster** than block ciphers. | RC4, SEAL |

---
#### Use Case
*   Because it is **fast and efficient**, symmetric encryption (specifically AES) is ideal for encrypting **large amounts of data** (bulk encryption), such as the data flowing through a **VPN tunnel**.


---

# 18.1.3: Asymmetric Encryption

#### Core Concept
*   **Asymmetric Encryption** (or public-key cryptography) uses a **key pair**: a **public key** and a **private key**.
*   These keys are mathematically linked. Data encrypted with the public key can **only** be decrypted by its corresponding private key.
*   The **public key** can be shared freely with anyone. The **private key** must be kept secret by its owner.

---
#### Key Characteristics

*   **Speed:** **Substantially slower** than symmetric encryption due to complex mathematical operations.
*   **Key Length:** Uses very long keys for security. A minimum key length of **2,048 bits** is recommended for trust.
*   **Key Management:** Often simpler than symmetric because you don't need a secure channel to share the public key.

---
#### Primary Use Cases
Because it is slow, asymmetric encryption is **not** used for encrypting bulk data. Instead, it is used for low-volume, high-security tasks:

1.  **Secure Key Exchange:** Its most common use. It securely encrypts and exchanges a **symmetric key** at the beginning of a session (like in HTTPS). The rest of the session then uses the faster symmetric encryption.
2.  **Digital Signatures:** Provides authenticity and non-repudiation by proving the identity of the sender.

---
#### Common Protocols Using Asymmetric Encryption
*   **IKE (Internet Key Exchange):** Used in IPsec VPNs to negotiate keys.
*   **SSL/TLS (Secure Sockets Layer / Transport Layer Security):** The foundation of HTTPS.
*   **SSH (Secure Shell):** Used for secure remote access.
*   **PGP (Pretty Good Privacy):** Used for encrypting and signing emails.

---
#### Common Asymmetric Algorithms

| Algorithm                | Primary Use / Key Feature                                                                                                                               |
| :----------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Diffie-Hellman (DH)**  | **Secure Key Exchange.** Allows two parties to agree on a shared secret key over an insecure channel.                                                   |
| **DSS / DSA**            | **Digital Signatures Only.** The standard for creating digital signatures, not for encryption.                                                          |
| **RSA**                  | **Encryption and Digital Signatures.** The most widely used public-key algorithm.                                                                       |
| **ElGamal**              | Based on Diffie-Hellman. Used for encryption, but the resulting ciphertext is large, so it's best for small amounts of data.                            |
| **ECC (Elliptic Curve)** | Provides the same level of security as other algorithms but with **much smaller key sizes**, making it more efficient for mobile and low-power devices. |


---

# 18.1.4: Asymmetric Encryption for Confidentiality

#### The Formula for Confidentiality
To send a secret message that only the recipient can read, the process is:
**Public Key (Encrypt) + Private Key (Decrypt) = Confidentiality**

---
#### The Step-by-Step Process (Alice sends a secret message to Bob)

1.  **Step 1: Alice Acquires Bob's Public Key**
    *   Alice requests Bob's public key.
    *   Bob sends his public key to Alice over the network. This transaction does not need to be secure, as the public key is meant to be shared.

2.  **Step 2: Alice Encrypts the Message**
    *   Alice uses **Bob's public key** to encrypt her message.
    *   Once encrypted, the resulting ciphertext can **only** be decrypted by **Bob's private key**.

3.  **Step 3: Bob Decrypts the Message**
    *   Alice sends the encrypted message to Bob.
    *   Bob uses his own **private key** to decrypt the message and read the original plaintext.
    *   **Result:** Since Bob is the only one with his private key, confidentiality is achieved. No one else who may have intercepted the message can read it.


---

# 18.1.5: Asymmetric Encryption for Authentication

#### The Formula for Authentication
To prove that a message came from a specific sender, the process is the reverse of confidentiality:
**Private Key (Encrypt) + Public Key (Decrypt) = Authentication**

---
#### The Step-by-Step Process (Alice proves her identity to Bob)

1.  **Step 1: Alice Encrypts with her Private Key**
    *   Alice wants to send a message and prove it's really from her.
    *   She uses her **own private key** to encrypt the message (or more commonly, a hash of the message).
    *   **Result:** This creates a digital signature. Only Alice could have created it, because only she has her private key.

2.  **Step 2: Bob Acquires Alice's Public Key**
    *   Alice sends the signed message to Bob.
    *   To verify the signature, Bob needs Alice's public key. He can request it from her or get it from a trusted source (like a certificate authority).

3.  **Step 3: Bob Decrypts with Alice's Public Key**
    *   Bob uses **Alice's public key** to decrypt the signature.
    *   **If it decrypts successfully**, it proves two things:
        1.  **Authentication:** The message must have come from Alice, because only her public key could decrypt something signed by her private key.
        2.  **Integrity:** The message was not altered in transit.

> **Note:** This process does **not** provide confidentiality. Anyone with Alice's public key can decrypt the message. Its sole purpose is to prove the identity of the sender.


---

# 18.1.6: Asymmetric Encryption for Confidentiality, Authentication, AND Integrity

#### Core Concept
By combining the two previous processes, asymmetric cryptography can provide all three security services at once.

*   **Confidentiality:** Encrypt the message with the **recipient's public key**.
*   **Authentication & Integrity:** Sign a hash of the message with the **sender's private key**.

---
#### The Complete Step-by-Step Process (Alice sends a secure & signed message to Bob)

1.  **Step 1: Alice Provides Confidentiality**
    *   Alice takes her plaintext message.
    *   She encrypts the **entire message** using **Bob's public key**.
    *   **Result:** Only Bob (with his private key) can read the message.

2.  **Step 2: Alice Provides Authentication & Integrity**
    *   Alice takes her original plaintext message and creates a **hash** of it.
    *   She then encrypts this **hash** using her **own private key**. This creates the digital signature.
    *   Alice sends the **encrypted message** and the **encrypted hash (signature)** together to Bob.

3.  **Step 3: Bob Verifies Authentication & Integrity**
    *   Bob receives the package from Alice.
    *   He uses **Alice's public key** to decrypt the encrypted hash. This reveals the original hash that Alice calculated.
    *   Bob then takes the encrypted message, but before decrypting it, he also calculates his own hash of it. (Note: The course simplifies this; in reality, he would decrypt the message *first* and then hash the resulting plaintext).
    *   He compares the hash he just calculated with the one he decrypted from Alice's signature.
    *   **Result:** If the hashes match, it proves **authentication** (it came from Alice) and **integrity** (it wasn't altered).

4.  **Step 4: Bob Decrypts for Confidentiality**
    *   After verifying the signature, Bob uses his **own private key** to decrypt the main message.
    *   **Result:** Bob can now read the secret message, and he is certain it came from Alice and was not tampered with.


---

# 18.1.7: Diffie-Hellman (DH) Key Exchange

#### Core Concept
*   **Diffie-Hellman (DH)** is an asymmetric algorithm used for one specific purpose: to allow two parties, who have no prior shared secret, to securely agree upon a **new, identical shared secret key** over an insecure public channel.
*   **Key Feature:** The final shared key is **never actually transmitted** across the network. It is calculated independently by both sides.

---
#### How It Works (The Paint Analogy)

| Step | Action | Analogy |
| :--- | :--- | :--- |
| **1** | **Agree on Public Value** | Alice and Bob publicly agree on a starting value (a prime number). | Agree on a public color: **Yellow**. |
| **2** | **Generate Private Keys** | Alice and Bob each secretly choose a random private number. | Alice secretly picks **Red**. Bob secretly picks **Blue**. |
| **3** | **Calculate Public Keys** | Alice and Bob each combine the public value with their private key to create a public key. | Alice mixes Yellow + Red = **Orange**. Bob mixes Yellow + Blue = **Green**. |
| **4** | **Exchange Public Keys** | Alice sends her public key to Bob, and Bob sends his public key to Alice. | Alice sends **Orange** to Bob. Bob sends **Green** to Alice. |
| **5** | **Calculate Final Shared Key**| Each party combines the key they *received* with their *own original private key*. | Alice mixes Green + Red = **Brown**. Bob mixes Orange + Blue = **Brown**. |

**Result:** Both Alice and Bob have independently calculated the exact same final key (**Brown**) without ever sending it across the wire. An eavesdropper who only saw the public values (**Yellow, Orange, Green**) cannot easily calculate the final key.

---
#### DH Groups & Security
*   The security of DH relies on using very large prime numbers.
*   **DH Groups** define the bit length (and therefore the strength) of the numbers used. Higher group numbers are more secure but require more processing time.
*   **Common Groups (Cisco IOS):**
    *   Group 14: 2048 bits (common minimum standard)
    *   Group 16: 4096 bits (stronger)
    *   Elliptic Curve DH (Groups 19, 20, 24): Provides high security with smaller key sizes.

---
#### Primary Use Case
*   DH is used to securely generate a **symmetric key** at the start of a session.
*   The bulk of the data is then encrypted using that fast, newly-created symmetric key (e.g., with AES).
*   **Common Applications:** IPsec VPNs, SSH, TLS.