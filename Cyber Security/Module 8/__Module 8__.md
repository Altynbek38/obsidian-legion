
# **Linux Basics**

# Linux
**Linux** is open an open-source operating system that is fast, powerful, highly customizable. It is built for network use as either a client or server. Linux is well-loved by a large community of users, including cybersecurity personnel.
[[Linux]]

# Linux distribution
A **Linux distribution** is the term used to describe packages created by different organizations. Linux distributions (or distros) include the Linux kernel with customized tools and software packages.  [[Linux distribution]]

# The Value of Linux
**Linux is open source**- Any person can acquire Linux at no charge and modify it to fit specific needs. This flexibility allows analysts and administrators to tailor-build an operating system specifically for security analysis.
**The Linux CLI is very powerful -** While a GUI makes many tasks easier to perform, it adds complexity and requires more computer resources to run. The Linux Command Line Interface (CLI) is extremely powerful and enables analysts to perform tasks not only directly on a terminal, but also remotely.
**The user has more control over the OS -** The administrator user in Linux, known as the root user, or superuser, has absolute power over the computer.  It allows the root user to have precise control over the way network packets are handled by the operating system.
**It allows for better network communication control -** Control is an inherent part of Linux. Because the OS can be adjusted in practically every aspect, it is a great platform for creating network applications. 
[[Value of Linux]]

# Linux in the SOC
**Sguil** - cybersecurity analyst console in a special version of the Linux called Linux Security Onion.
**Security Onion** - an open source suite of tools that work together for network security analysis. 

**Network packer capture software** - A crucial tool for a SOC analyst as it makes it possible to observe and understand every detail of a network transaction. 
**Malware analysis tool** - These tools allow analysts to safely run and observe malware execution without the risk of compromising the underlying system.
**Intrusion Detection Systems** - These tools are used for real-time traffic monitoring and inspection. If any aspect of the currently flowing traffic matches any of the established rules, a pre-defined action is taken.
**Firewalls** - This software is used to specify, based on pre-defined rules, whether traffic is allowed to enter or leave a network or device.
**Log managers** - Log files are used to record events. Because a network can generate a very large number of log entries, log manager software is employed to facilitate log monitoring.
**Security Information and event management (SIEM)** - SIEMs provide real-time analysis of alerts and log entries generated by network appliances such as IDSs and firewalls.
**Ticketing System** - Task ticket assignment, editing, and recording is done through a ticket management system. Security alerts are often assigned to analysts through a ticketing system.

**PenTesting** - a penetration test is the process of looking for vulnerabilities in a network or computer by attacking it.
[[Linux in the SOC]]


# **Working in the Linux Shell**

# Basic Commands
[[Basic Commands]]


# Working with Text Files
Linux offers both graphical and command-line text editors. While graphical editors are user-friendly, command-line editors like **nano** are essential for remote administration via SSH, where no GUI is available. They are commonly used for editing system configuration files and performing maintenance tasks.

In Linux, everything — including devices and directories — is treated as a file. System settings are stored in **configuration files**, which are text files controlling how services and applications work. Users with proper permissions can edit these files using text editors. For example, the **/etc/hosts** file maps IP addresses to hostnames and can be edited with superuser privileges using the command:  
`sudo nano /etc/hosts`.

[[Working with Text Files]]


# **Linux Servers and Clients**

# Client-Server Communications
**Servers** are computers that provide services to clients over a network. Each service, such as file sharing, email, or web hosting, requires specific server software. Some servers also handle maintenance tasks like log or memory management. For example, a file server allows clients to upload and download files.
[[Client-Server Communications]]


# Servers, Services, and Their Ports
Ports allow a server to provide multiple services at the same time. Each service uses a specific port, and when a server is “listening” on a port, it’s ready to handle requests for that service. Although administrators can change port numbers, most services use default or “well-known” ports so clients can connect easily.
[[Servers, Services, and Their Ports]]


# Clients
Clients are applications that communicate with servers using specific protocols. For example, web browsers use **HTTP** on port **80** to connect to web servers, while **FTP clients** use the **File Transfer Protocol** to exchange files with FTP servers.
[[Clients]]


# **Basic Server Administration**

# Service Configuration Files
In Linux, services are controlled through **configuration files** that define settings like port numbers, resource locations, and access permissions. When a service starts, it loads these files to apply the settings. Changes usually require a service restart. Since most services need superuser rights, editing their configuration files also requires **superuser privileges**. For example, **Nginx** is a lightweight web server managed this way.


# Hardening Devices
Device hardening means securing a system and protecting administrative access. It includes managing passwords, using secure SSH logins, and defining user access levels. Unnecessary default services should be disabled, and the OS must be kept updated to prevent vulnerabilities.

**Basic best practices include:**

- Ensure physical security
    
- Minimize installed packages
    
- Disable unused services
    
- Use SSH (disable root login)
    
- Keep the system updated
    
- Disable USB auto-detection
    
- Enforce strong, regularly changed passwords
    
- Prevent password reuse


# Monitoring Service Logs
Log files record important system, service, and application events in Linux. Regularly reviewing them helps administrators monitor performance, detect security issues, and prevent problems. Logs are typically divided into **application**, **event**, **service**, and **system** logs. Some logs track **daemons**—background processes like **SSSD**, which manages remote access and authentication.

| Linux Log File | Description |
|---|---|
| `/var/log/messages` | Stores generic, informational, and non-critical system messages. (On Debian/Ubuntu, `/var/log/syslog` is used instead). |
| `/var/log/auth.log` | Records all authentication-related events on Debian and Ubuntu systems. |
| `/var/log/secure` | The equivalent of `auth.log` for RedHat/CentOS systems; tracks sudo, SSH, and other login events. |
| `/var/log/boot.log` | Contains messages logged during the system's startup process. |
| `/var/log/dmesg` | Contains kernel ring buffer messages, primarily related to hardware devices and drivers. |
| `/var/log/kern.log` | Stores information logged directly by the system kernel. |
| `/var/log/cron` | Records all events related to the execution of scheduled tasks (cron jobs). |
| `/var/log/mysqld.log` or `/var/log/mysql.log` | The primary log file for the MySQL database server, containing debug information, errors, and success messages. |


# **The Linux File System**

# The File System Types in Linux
**ext2** was the default Linux file system before being replaced by **ext3**, which added journaling. ext2 remains popular for **flash storage** because it lacks a journal, reducing write operations and extending device lifespan. Modern Linux systems use **ext4**, which offers better performance and can also run without journaling

**ext3** is a **journaled file system** that improves upon **ext2** by adding a **journal** to reduce the risk of corruption from power loss or crashes. It records pending changes in a log, allowing recovery if a crash occurs before completion. The **maximum file size** supported by ext3 is **32 TB**.

**ext4** is the successor to **ext3**, built from extensions that improved performance and supported larger file sizes. To maintain **stability**, developers split the project—**ext3** continued as the stable version, while **ext4** included the new enhancements as a separate file system.

**NFS (Network File System)** allows files to be accessed and shared over a network as if they were on the local computer. It provides seamless remote file access and is an **open standard**, meaning anyone can implement it.

**CDFS** was created specifically for optical disk media.

The **swap file system** is used when Linux runs out of **RAM**. It uses a **swap partition** (not a true file system) where the kernel moves inactive memory contents to disk. This helps systems with limited memory but is much **slower than RAM**, so it should not be relied on as a primary memory solution.

**HFS Plus (HFS+ - Hierarchical File Sytem Plus)** is the file system used by **Apple’s macOS**. Linux supports **read and write access** to HFS+ drives through a kernel module.

**APFS (Apple File System)** is the modern file system used by **Apple devices**, offering **strong encryption**, improved performance, and optimization for **flash and SSD storage**.

The **Master Boot Record (MBR)** is located in the **first sector** of a storage device and contains information about the **disk’s partitions and file system organization**. It also includes a **boot loader** that transfers control to the operating system during startup.

**Mounting** is the process of linking a **partition** to a **directory**, making its file system accessible through that directory, called the **mount point**. In Linux, the **root file system ("/")** is the main mount point that contains all files by default. For example, the output shows the root file system on **/dev/sda1**, formatted as **ext4**.


# Linux Roles and File Permissions
In Linux, everything is treated as a file, and **file permissions** control who can access or modify files. Each file has three permission sets — for the **user**, **group**, and **others** — defining whether they can **read (r)**, **write (w)**, or **execute (x)** it.

Example:  
`-rwxrw-r-- 1 analyst staff 253 May 20 12:49 space.txt`

- `-` → regular file (`d` would mean directory)
    
- `rwx` → user (owner) can read, write, execute
    
- `rw-` → group can read, write
    
- `r--` → others can only read

| Binary | Octal | Permission | Description |
|---|---|---|---|
| 000 | 0 | `---` | No access |
| 001 | 1 | `--x` | Execute only |
| 010 | 2 | `-w-` | Write only |
| 011 | 3 | `-wx` | Write and Execute |
| 100 | 4 | `r--` | Read only |
| 101 | 5 | `r-x` | Read and Execute |
| 110 | 6 | `rw-` | Read and Write |
| 111 | 7 | `rwx` | Read, Write and Execute |

Other details include the number of links, owner, group, size, and modification date.  
Permissions can also be expressed in **octal form** (e.g., 7 = rwx, 6 = rw-, 4 = r--).

Only the **root user** can override permissions and access any file. Because root has full control, its password must be strong and used only by trusted administrators.


# Hard Links and Symbolic Links
A **hard link** is another file that points to the same data location as the original file. Both share the same content—changes to one affect the other.

- Create a hard link: `ln original.txt link.txt`
    
- Deleting one does not remove the data until all linked files are deleted.
    

A **symbolic link (symlink or soft link)** is a shortcut that points to another file’s path.

- Create a symlink: `ln -s original.txt link.txt`
    
- If the original file is deleted, the symlink becomes broken.
    

**Differences:**

- Hard links share the same data; symlinks point to a file path.
    
- Hard links work only within the same file system; symlinks can cross file systems.
    
- Hard links can’t link to directories; symlinks can.
    
- Symlinks show the original file’s path (e.g., `mytest.txt -> test.txt`).


# **Working with the Linux GUI**

# X Window System
The **X Window System (X or X11)** provides the basic framework for Linux graphical interfaces. It handles window drawing, mouse, and keyboard input. X acts as a **server**, allowing remote users to run graphical applications over a network.

X itself doesn’t define the **user interface** — that’s done by **window managers** like **GNOME** and **KDE**, which control the appearance of windows, icons, and menus. This separation makes Linux GUIs highly **customizable and varied** across distributions.


# The Linux GUI
While Linux can run without a **GUI**, graphical interfaces are more **user-friendly** than the command line.  
**Ubuntu**, one of the most popular Linux distributions, uses **GNOME 3** as its default desktop environment to enhance usability.

GNOME 3 provides a clean and simple interface with key UI components such as the **Activities overview**, **top bar**, and **dock**, making Ubuntu intuitive and easy to navigate.


# **Working on a Linux Host**

# Installing and Running Applications on a Linux Host
Package managers simplify software installation and updates in Linux.  
A **package** includes a program and all its required files. Different Linux distributions use different package managers — for example, **pacman** for Arch Linux and **apt/dpkg** for Debian or Ubuntu.

- `sudo apt-get update` downloads the latest package lists from the repositories and updates the local database.
    
- `sudo apt-get upgrade` upgrades all installed packages to their newest available versions.
    

These tools ensure that software is installed correctly and kept up to date.


# Keeping the System Up to Date
Operating system updates — also called **patches** — are released to fix security vulnerabilities and improve performance. They can be **scheduled** (regular updates) or **unscheduled** (emergency fixes for critical issues).

Modern systems notify users when updates are available, but users can also check manually.

In Linux, updates can be done via **CLI** or **GUI**.  
Here’s a summary of common commands:

| **Task**             | **Arch Linux** | **Debian/Ubuntu** |
| -------------------- | -------------- | ----------------- |
| Install a package    | `pacman -S`    | `apt install`     |
| Remove a package     | `pacman -Rs`   | `apt remove`      |
| Update package list  | `pacman -Syy`  | `apt-get update`  |
| Upgrade all packages | `pacman -Syu`  | `apt-get upgrade` |


# Processes and Forks
A **process** is a running instance of a program. In **multitasking operating systems**, multiple processes can run at once.

In **Linux**, new processes are created using **forking**, where a process duplicates itself.

- The **parent process** creates a **child process** with a new **Process ID (PID)**.
    
- Both run the same code but operate independently.
    
- This method improves **scalability** — for example, **Apache web server** uses forking to handle many requests efficiently.
    

Here are key commands for managing processes in Linux:

| **Command** | **Description**                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------- |
| `ps`        | Lists currently running processes. Can show processes by user or system-wide.                                       |
| `top`       | Dynamically displays active processes in real time. Press **q** to quit.                                            |
| `kill`      | Sends signals to processes (e.g., stop, pause, or terminate). Usually used after finding the PID via `ps` or `top`. |


# Malware on a Linux Host
Linux can get malware (viruses, trojans, worms), but its file-permission model and account restrictions make it harder to exploit than some OSes—still, it’s **not immune**. Attackers commonly target network services and unpatched software by probing open ports (e.g., using `telnet` to discover `nginx/1.12.0`) and then looking for known vulnerabilities.  
**Defenses:** keep the system and services patched, close/disable unused services and ports, enforce least privilege, and monitor logs for suspicious activity.


# Rootkit Check
A rootkit is stealthy malware that elevates unauthorized access and alters the OS (often kernel code) to hide itself and backdoors. Because it tampers with fundamental OS components, detection and removal are very difficult — full OS reinstallation is often the only reliable fix (firmware rootkits may need hardware replacement).

**Detection methods (brief):**

- Boot from trusted media (live CD/USB) and inspect the compromised drive.
    
- Behavioral analysis, signature scanning, difference scanning, memory-dump analysis.
    
- Tools like **chkrootkit** scan for known rootkits by checking binaries and `/proc` for discrepancies — useful but **not 100% reliable**.
    

**Example:**  
Run a check with: `sudo ./chkrootkit`

**Quick mitigation tips:** keep systems patched, limit root access, monitor logs, and use trusted recovery media for forensic checks.


# Piping Commands
Piping (`|`) chains commands so the **output of one** becomes the **input of the next**, letting you build more complex filters from simple tools.  
Example: `ls -l | grep host` shows only `ls -l` lines that contain “host”.
